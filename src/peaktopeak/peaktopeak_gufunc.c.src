//
// peaktopeak_gufunc.c
//

#include <stdio.h>
#include <stdint.h>

#define NPY_NO_DEPRECATED_API NPY_API_VERSION

#define PY_SSIZE_T_CLEAN
#include "Python.h"
#include "math.h"
#include "numpy/ndarraytypes.h"
#include "numpy/ufuncobject.h"


// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// Loops for signed integers.
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

/**begin repeat
 * #typename = int8, int16, int32, int64#
 * #ctype_in  = int8_t, int16_t, int32_t, int64_t#
 * #ctype_out = uint8_t, uint16_t, uint32_t, uint64_t#
 */

static @ctype_out@ max_diff_@typename@(@ctype_in@ xmax, @ctype_in@ xmin) {
    if ((xmax > 0 && xmin > 0) || (xmax < 0 && xmin < 0)) {
        return xmax - xmin;
    }
    else {
        return xmax + (@ctype_out@) (-xmin);
    }
}

static void peaktopeak_@typename@_loop(char **args, npy_intp *dimensions,
                                   npy_intp* steps, void* data)
{
    char *in = args[0];
    char *out = args[1];
    npy_intp in_step = steps[0];
    npy_intp out_step = steps[1];
    npy_intp inner_step = steps[2];

    for (npy_intp i = 0; i < dimensions[0]; ++i, in += in_step, out += out_step) {
        char *inner = in;
        @ctype_in@ xmin = *(@ctype_in@ *) inner;
        @ctype_in@ xmax = xmin;
        // XXX This assumes dimensions[1] is at least 1!
        inner += inner_step;
        for (npy_intp k = 1; k < dimensions[1]; ++k, inner += inner_step) {
            @ctype_in@ x = *(@ctype_in@ *)inner;
            if (x < xmin) {
                xmin = x;
            }
            else if (x > xmax) {
                xmax = x;
            }
        }
        *(@ctype_out@ *) out = max_diff_@typename@(xmax, xmin);
    }
}
/**end repeat**/

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// Loops for unsigned integers and floating point types.
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

/**begin repeat
 * #typename = uint8, uint16, uint32, uint64, float, double, longdouble#
 * #ctype = uint8_t, uint16_t, uint32_t, uint64_t, float, double, long double#
 */ 
static void peaktopeak_@typename@_loop(char **args, npy_intp *dimensions,
                                      npy_intp* steps, void* data)
{
    char *in = args[0];
    char *out = args[1];
    npy_intp in_step = steps[0];
    npy_intp out_step = steps[1];
    npy_intp inner_step = steps[2];

    for (npy_intp i = 0; i < dimensions[0]; ++i, in += in_step, out += out_step) {
        char *inner = in;
        @ctype@ xmin = *(@ctype@ *) inner;
        @ctype@ xmax = xmin;
        // XXX This assumes dimensions[1] is at least 1!
        inner += inner_step;
        for (npy_intp k = 1; k < dimensions[1]; ++k, inner += inner_step) {
            @ctype@ x = *(@ctype@ *)inner;
            if (x < xmin) {
                xmin = x;
            }
            else if (x > xmax) {
                xmax = x;
            }
        }
        *(@ctype@ *) out = xmax - xmin;
    }
}
/**end repeat**/

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// ufunc configuration data.
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

// These are the input and return dtypes of peaktopeak.
// The order of matters!  If the array starts, say,
//    NPY_INT8, NPY_UINT8,
//    NPY_INT16, NPY_UINT16,
//    NPY_INT32, NPY_UINT32,
//    NPY_INT64, NPY_UINT64,
//    NPY_UINT8, NPY_UINT8,
//    ...
// then the result for an input with dtype np.uint8 will
// have dtype np.uint16.
static char types[] = {
    NPY_INT8, NPY_UINT8,
    NPY_UINT8, NPY_UINT8,
    NPY_INT16, NPY_UINT16,
    NPY_UINT16, NPY_UINT16,
    NPY_INT32, NPY_UINT32,
    NPY_UINT32, NPY_UINT32,
    NPY_INT64, NPY_UINT64,
    NPY_UINT64, NPY_UINT64,
    NPY_FLOAT, NPY_FLOAT,
    NPY_DOUBLE, NPY_DOUBLE,
    NPY_LONGDOUBLE, NPY_LONGDOUBLE
};

PyUFuncGenericFunction funcs[] = {
    &peaktopeak_int8_loop,
    &peaktopeak_uint8_loop,
    &peaktopeak_int16_loop,
    &peaktopeak_uint16_loop,
    &peaktopeak_int32_loop,
    &peaktopeak_uint32_loop,
    &peaktopeak_int64_loop,
    &peaktopeak_uint64_loop,
    &peaktopeak_float_loop,
    &peaktopeak_double_loop,
    &peaktopeak_longdouble_loop
};

static void *data[] = {NULL, NULL, NULL, NULL, NULL, NULL};


// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// Python extension module definitions.
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

static PyMethodDef PeakToPeakMethods[] = {
        {NULL, NULL, 0, NULL}
};

static struct PyModuleDef moduledef = {
    PyModuleDef_HEAD_INIT,
    .m_name = "_peaktopeak",
    .m_doc = "Module that defines the peaktopeak function.",
    .m_size = -1,
    .m_methods = PeakToPeakMethods
};


#define PEAKTOPEAK_DOCSTRING                                        \
    "Peak-to-peak value (i.e. maximum - minimum) of an array.\n"    \
    "\n"                                                            \
    "An unsigned integer is returned for signed integer input.\n"


PyMODINIT_FUNC PyInit__peaktopeak(void)
{
    PyObject *m;
    PyObject *peaktopeak_gufunc;
    PyObject *d;
    size_t ntypes;
    int nin, nout;

    m = PyModule_Create(&moduledef);
    if (!m) {
        return NULL;
    }

    import_array();
    import_umath();

    // Create the peaktopeak ufunc.

    ntypes = sizeof(funcs) / sizeof(funcs[0]);
    nin = 1;
    nout = 1;
    peaktopeak_gufunc = PyUFunc_FromFuncAndDataAndSignature(
                            funcs, data, types, ntypes, nin, nout,
                            PyUFunc_None, "peaktopeak",
                            PEAKTOPEAK_DOCSTRING, 0,
                            "(i)->()");

    d = PyModule_GetDict(m);
    PyDict_SetItemString(d, "peaktopeak", peaktopeak_gufunc);
    Py_DECREF(peaktopeak_gufunc);

    return m;
}
