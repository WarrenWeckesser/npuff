//
// minmax_gufunc.c
//

#define PY_SSIZE_T_CLEAN
#include "Python.h"

#include <stddef.h>
#include <stdint.h>

#define NPY_NO_DEPRECATED_API NPY_API_VERSION
#include "numpy/ndarraytypes.h"
#include "numpy/ufuncobject.h"

#include "../util/ufunc_tools.h"

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// ufunc inner loops for integer and floating point types.
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

/**begin repeat
 * #typename = int8,    int16,    int32,    int64,     uint8,   uint16,   uint32,   uint64,   float, double, longdouble#
 * #ctype    = int8_t,  int16_t,  int32_t,  int64_t,   uint8_t, uint16_t, uint32_t, uint64_t, float, double, long double#
 */

static void minmax_@typename@_loop(char **args, const npy_intp *dimensions,
                                   const npy_intp* steps, void* data)
{
    char *in = args[0];
    char *out = args[1];
    npy_intp in_step = steps[0];
    npy_intp out_step = steps[1];
    npy_intp core_in_step = steps[2];
    npy_intp core_out_step = steps[3];

    if (dimensions[1] == 0) {
        NPY_ALLOW_C_API_DEF
        NPY_ALLOW_C_API
        PyErr_SetString(PyExc_ValueError,
                        "minmax requires an input with length at least 1.");
        NPY_DISABLE_C_API
        return;
    }

    for (npy_intp i = 0; i < dimensions[0]; ++i, in += in_step, out += out_step) {
        char *inner = in;
        @ctype@ xmin = *(@ctype@ *) inner;
        @ctype@ xmax = xmin;
        inner += core_in_step;
        for (npy_intp k = 1; k < dimensions[1]; ++k, inner += core_in_step) {
            @ctype@ x = *(@ctype@ *)inner;
            if (x < xmin) {
                xmin = x;
            }
            else if (x > xmax) {
                xmax = x;
            }
        }
        *((@ctype@ *) out) = xmin;
        *((@ctype@ *) (out + core_out_step)) = xmax;
    }
}

static void argminmax_@typename@_loop(char **args, const npy_intp *dimensions,
                                      const npy_intp* steps, void* data)
{
    char *in = args[0];
    char *out = args[1];
    npy_intp in_step = steps[0];
    npy_intp out_step = steps[1];
    npy_intp core_in_step = steps[2];
    npy_intp core_out_step = steps[3];

    if (dimensions[1] == 0) {
        NPY_ALLOW_C_API_DEF
        NPY_ALLOW_C_API
        PyErr_SetString(PyExc_ValueError,
                        "argminmax requires an input with length at least 1.");
        NPY_DISABLE_C_API
        return;
    }

    for (npy_intp i = 0; i < dimensions[0]; ++i, in += in_step, out += out_step) {
        char *inner = in;
        @ctype@ xmin = *(@ctype@ *) inner;
        npy_intp xmin_index = 0;
        @ctype@ xmax = xmin;
        npy_intp xmax_index = 0;
        inner += core_in_step;
        for (npy_intp k = 1; k < dimensions[1]; ++k, inner += core_in_step) {
            @ctype@ x = *(@ctype@ *)inner;
            if (x < xmin) {
                xmin = x;
                xmin_index = k;
            }
            else if (x > xmax) {
                xmax = x;
                xmax_index = k;
            }
        }
        *((npy_intp *) out) = xmin_index;
        *((npy_intp *) (out + core_out_step)) = xmax_index;
    }
}

/**begin repeat1
 *
 * #op = min, max#
 * #cmp = <, >#
 */

static void arg@op@_@typename@_loop(char **args, const npy_intp *dimensions,
                                    const npy_intp* steps, void* data)
{
    char *in = args[0];
    char *out = args[1];
    npy_intp in_step = steps[0];
    npy_intp out_step = steps[1];
    npy_intp core_in_step = steps[2];

    if (dimensions[1] == 0) {
        NPY_ALLOW_C_API_DEF
        NPY_ALLOW_C_API
        PyErr_SetString(PyExc_ValueError,
                        "arg@op@ requires an input with length at least 1.");
        NPY_DISABLE_C_API
        return;
    }

    for (npy_intp i = 0; i < dimensions[0]; ++i, in += in_step, out += out_step) {
        char *inner = in;
        @ctype@ x_extreme = *(@ctype@ *) inner;
        npy_intp x_index = 0;
        inner += core_in_step;
        for (npy_intp k = 1; k < dimensions[1]; ++k, inner += core_in_step) {
            @ctype@ x = *(@ctype@ *) inner;
            if (x @cmp@ x_extreme) {
                x_extreme = x;
                x_index = k;
            }
        }
        *((npy_intp *) out) = x_index;
    }
}

static void @op@_arg@op@_@typename@_loop(char **args, const npy_intp *dimensions,
                                         const npy_intp* steps, void* data)
{
    char *in = args[0];
    char *out1 = args[1];
    char *out2 = args[2];
    npy_intp in_step = steps[0];
    npy_intp out1_step = steps[1];
    npy_intp out2_step = steps[2];
    npy_intp core_in_step = steps[3];

    if (dimensions[1] == 0) {
        NPY_ALLOW_C_API_DEF
        NPY_ALLOW_C_API
        PyErr_SetString(PyExc_ValueError,
                        "@op@_arg@op@ requires an input with length at least 1.");
        NPY_DISABLE_C_API
        return;
    }

    for (npy_intp i = 0; i < dimensions[0];
             ++i, in += in_step, out1 += out1_step, out2 += out2_step) {
        char *inner = in;
        @ctype@ x_extreme = *(@ctype@ *) inner;
        npy_intp x_index = 0;
        inner += core_in_step;
        for (npy_intp k = 1; k < dimensions[1]; ++k, inner += core_in_step) {
            @ctype@ x = *(@ctype@ *)inner;
            if (x @cmp@ x_extreme) {
                x_extreme = x;
                x_index = k;
            }
        }
        *((@ctype@ *) out1) = x_extreme;
        *((npy_intp *) out2) = x_index;
    }
}
/**end repeat1**/

/**end repeat**/


// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// ufunc inner loop for object arrays.
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

static void minmax_object_loop(char **args, const npy_intp *dimensions,
                               const npy_intp* steps, void* data)
{
    char *in = args[0];
    char *out = args[1];
    npy_intp in_step = steps[0];
    npy_intp out_step = steps[1];
    npy_intp core_in_step = steps[2];
    npy_intp core_out_step = steps[3];

    if (dimensions[1] == 0) {
        PyErr_SetString(PyExc_ValueError,
                        "minmax requires an input with length at least 1.");
        return;
    }

    for (npy_intp i = 0; i < dimensions[0]; ++i, in += in_step, out += out_step) {
        char *inner = in;
        PyObject *xmin = *(PyObject **) inner;
        PyObject *xmax = xmin;
        inner += core_in_step;
        for (npy_intp k = 1; k < dimensions[1]; ++k, inner += core_in_step) {
            PyObject *x = *(PyObject **) inner;
            int lt = PyObject_RichCompareBool(x, xmin, Py_LT);
            if (lt == -1) {
                return;
            }
            if (lt == 1) {
                xmin = x;
            }
            else {
                int gt = PyObject_RichCompareBool(x, xmax, Py_GT);
                if (gt == -1) {
                    return;
                }
                if (gt == 1) {
                    xmax = x;
                }
            }
        }
        Py_INCREF(xmin);
        Py_INCREF(xmax);
        *((PyObject **) out) = xmin;
        *((PyObject **) (out + core_out_step)) = xmax;
    }
}


static void argminmax_object_loop(char **args, const npy_intp *dimensions,
                                  const npy_intp* steps, void* data)
{
    char *in = args[0];
    char *out = args[1];
    npy_intp in_step = steps[0];
    npy_intp out_step = steps[1];
    npy_intp core_in_step = steps[2];
    npy_intp core_out_step = steps[3];

    if (dimensions[1] == 0) {
        PyErr_SetString(PyExc_ValueError,
                        "argminmax requires an input with length at least 1.");
        return;
    }

    for (npy_intp i = 0; i < dimensions[0]; ++i, in += in_step, out += out_step) {
        char *inner = in;
        PyObject *xmin = *(PyObject **) inner;
        npy_intp xmin_index = 0;
        PyObject *xmax = xmin;
        npy_intp xmax_index = 0;
        inner += core_in_step;
        for (npy_intp k = 1; k < dimensions[1]; ++k, inner += core_in_step) {
            PyObject *x = *(PyObject **) inner;
            int lt = PyObject_RichCompareBool(x, xmin, Py_LT);
            if (lt == -1) {
                return;
            }
            if (lt == 1) {
                xmin = x;
                xmin_index = k;
            }
            else {
                int gt = PyObject_RichCompareBool(x, xmax, Py_GT);
                if (gt == -1) {
                    return;
                }
                if (gt == 1) {
                    xmax = x;
                    xmax_index = k;
                }
            }
        }
        *((npy_intp *) out) = xmin_index;
        *((npy_intp *) (out + core_out_step)) = xmax_index;
    }
}

/**begin repeat
 *
 * #op = min, max#
 * #cmp = Py_LT, Py_GT#
 */


static void arg@op@_object_loop(char **args, const npy_intp *dimensions,
                                const npy_intp* steps, void* data)
{
    char *in = args[0];
    char *out = args[1];
    npy_intp in_step = steps[0];
    npy_intp out_step = steps[1];
    npy_intp core_in_step = steps[2];


    if (dimensions[1] == 0) {
        PyErr_SetString(PyExc_ValueError,
                        "arg@op@ requires an input with length at least 1.");
        return;
    }

    for (npy_intp i = 0; i < dimensions[0]; ++i, in += in_step, out += out_step) {
        char *inner = in;
        PyObject *x_extreme = *(PyObject **) inner;
        npy_intp x_index = 0;
        inner += core_in_step;
        for (npy_intp k = 1; k < dimensions[1]; ++k, inner += core_in_step) {
            PyObject *x = *(PyObject **) inner;
            int test = PyObject_RichCompareBool(x, x_extreme, @cmp@);
            if (test == -1) {
                return;
            }
            if (test == 1) {
                x_extreme = x;
                x_index = k;
            }
        }
        *((npy_intp *) out) = x_index;
    }
}


static void @op@_arg@op@_object_loop(char **args, const npy_intp *dimensions,
                                     const npy_intp* steps, void* data)
{
    char *in = args[0];
    char *out1 = args[1];
    char *out2 = args[2];
    npy_intp in_step = steps[0];
    npy_intp out1_step = steps[1];
    npy_intp out2_step = steps[2];
    npy_intp core_in_step = steps[3];


    if (dimensions[1] == 0) {
        PyErr_SetString(PyExc_ValueError,
                        "@op@_arg@op@ requires an input with length at least 1.");
        return;
    }

    for (npy_intp i = 0; i < dimensions[0];
             ++i, in += in_step, out1 += out1_step, out2 += out2_step) {
        char *inner = in;
        PyObject *x_extreme = *(PyObject **) inner;
        npy_intp x_index = 0;
        inner += core_in_step;
        for (npy_intp k = 1; k < dimensions[1]; ++k, inner += core_in_step) {
            PyObject *x = *(PyObject **) inner;
            int test = PyObject_RichCompareBool(x, x_extreme, @cmp@);
            if (test == -1) {
                return;
            }
            if (test == 1) {
                x_extreme = x;
                x_index = k;
            }
        }
        Py_INCREF(x_extreme);
        *((PyObject **) out1) = x_extreme;
        *((npy_intp *) out2) = x_index;
    }
}

/**end repeat**/

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// ufunc configuration data.
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

static char minmax_typecodes[] = {
    NPY_INT8,       NPY_INT8,
    NPY_UINT8,      NPY_UINT8,
    NPY_INT16,      NPY_INT16,
    NPY_UINT16,     NPY_UINT16,
    NPY_INT32,      NPY_INT32,
    NPY_UINT32,     NPY_UINT32,
    NPY_INT64,      NPY_INT64,
    NPY_UINT64,     NPY_UINT64,
    NPY_FLOAT,      NPY_FLOAT,
    NPY_DOUBLE,     NPY_DOUBLE,
    NPY_LONGDOUBLE, NPY_LONGDOUBLE,
    NPY_OBJECT,     NPY_OBJECT
};

static PyUFuncGenericFunction minmax_funcs[] = {
    (PyUFuncGenericFunction) &minmax_int8_loop,
    (PyUFuncGenericFunction) &minmax_uint8_loop,
    (PyUFuncGenericFunction) &minmax_int16_loop,
    (PyUFuncGenericFunction) &minmax_uint16_loop,
    (PyUFuncGenericFunction) &minmax_int32_loop,
    (PyUFuncGenericFunction) &minmax_uint32_loop,
    (PyUFuncGenericFunction) &minmax_int64_loop,
    (PyUFuncGenericFunction) &minmax_uint64_loop,
    (PyUFuncGenericFunction) &minmax_float_loop,
    (PyUFuncGenericFunction) &minmax_double_loop,
    (PyUFuncGenericFunction) &minmax_longdouble_loop,
    (PyUFuncGenericFunction) &minmax_object_loop
};

#define MINMAX_NTYPES (sizeof(minmax_funcs)/sizeof(minmax_funcs[0]))
static void *minmax_data[MINMAX_NTYPES];

static char argminmax_typecodes[] = {
    NPY_INT8,       NPY_INTP,
    NPY_UINT8,      NPY_INTP,
    NPY_INT16,      NPY_INTP,
    NPY_UINT16,     NPY_INTP,
    NPY_INT32,      NPY_INTP,
    NPY_UINT32,     NPY_INTP,
    NPY_INT64,      NPY_INTP,
    NPY_UINT64,     NPY_INTP,
    NPY_FLOAT,      NPY_INTP,
    NPY_DOUBLE,     NPY_INTP,
    NPY_LONGDOUBLE, NPY_INTP,
    NPY_OBJECT,     NPY_INTP
};

static PyUFuncGenericFunction argminmax_funcs[] = {
    (PyUFuncGenericFunction) &argminmax_int8_loop,
    (PyUFuncGenericFunction) &argminmax_uint8_loop,
    (PyUFuncGenericFunction) &argminmax_int16_loop,
    (PyUFuncGenericFunction) &argminmax_uint16_loop,
    (PyUFuncGenericFunction) &argminmax_int32_loop,
    (PyUFuncGenericFunction) &argminmax_uint32_loop,
    (PyUFuncGenericFunction) &argminmax_int64_loop,
    (PyUFuncGenericFunction) &argminmax_uint64_loop,
    (PyUFuncGenericFunction) &argminmax_float_loop,
    (PyUFuncGenericFunction) &argminmax_double_loop,
    (PyUFuncGenericFunction) &argminmax_longdouble_loop,
    (PyUFuncGenericFunction) &argminmax_object_loop
};

#define ARGMINMAX_NTYPES (sizeof(argminmax_funcs)/sizeof(argminmax_funcs[0]))
static void *argminmax_data[ARGMINMAX_NTYPES];


/**begin repeat
 *
 * #op = min, max #
 * #OP = MIN, MAX #
 */

static char arg@op@_typecodes[] = {
    NPY_INT8,       NPY_INTP,
    NPY_UINT8,      NPY_INTP,
    NPY_INT16,      NPY_INTP,
    NPY_UINT16,     NPY_INTP,
    NPY_INT32,      NPY_INTP,
    NPY_UINT32,     NPY_INTP,
    NPY_INT64,      NPY_INTP,
    NPY_UINT64,     NPY_INTP,
    NPY_FLOAT,      NPY_INTP,
    NPY_DOUBLE,     NPY_INTP,
    NPY_LONGDOUBLE, NPY_INTP,
    NPY_OBJECT,     NPY_INTP
};

static PyUFuncGenericFunction arg@op@_funcs[] = {
    (PyUFuncGenericFunction) arg@op@_int8_loop,
    (PyUFuncGenericFunction) arg@op@_uint8_loop,
    (PyUFuncGenericFunction) arg@op@_int16_loop,
    (PyUFuncGenericFunction) arg@op@_uint16_loop,
    (PyUFuncGenericFunction) arg@op@_int32_loop,
    (PyUFuncGenericFunction) arg@op@_uint32_loop,
    (PyUFuncGenericFunction) arg@op@_int64_loop,
    (PyUFuncGenericFunction) arg@op@_uint64_loop,
    (PyUFuncGenericFunction) arg@op@_float_loop,
    (PyUFuncGenericFunction) arg@op@_double_loop,
    (PyUFuncGenericFunction) arg@op@_longdouble_loop,
    (PyUFuncGenericFunction) arg@op@_object_loop
};

#define ARG@OP@_NTYPES (sizeof(arg@op@_funcs) / sizeof(arg@op@_funcs[0]))
static void *arg@op@_data[ARG@OP@_NTYPES];

static char @op@_arg@op@_typecodes[] = {
    NPY_INT8,       NPY_INT8,       NPY_INTP,
    NPY_UINT8,      NPY_UINT8,      NPY_INTP,
    NPY_INT16,      NPY_INT16,      NPY_INTP,
    NPY_UINT16,     NPY_UINT16,     NPY_INTP,
    NPY_INT32,      NPY_INT32,      NPY_INTP,
    NPY_UINT32,     NPY_UINT32,     NPY_INTP,
    NPY_INT64,      NPY_INT64,      NPY_INTP,
    NPY_UINT64,     NPY_UINT64,     NPY_INTP,
    NPY_FLOAT,      NPY_FLOAT,      NPY_INTP,
    NPY_DOUBLE,     NPY_DOUBLE,     NPY_INTP,
    NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_INTP,
    NPY_OBJECT,     NPY_OBJECT,     NPY_INTP
};

static PyUFuncGenericFunction @op@_arg@op@_funcs[] = {
    (PyUFuncGenericFunction) &@op@_arg@op@_int8_loop,
    (PyUFuncGenericFunction) &@op@_arg@op@_uint8_loop,
    (PyUFuncGenericFunction) &@op@_arg@op@_int16_loop,
    (PyUFuncGenericFunction) &@op@_arg@op@_uint16_loop,
    (PyUFuncGenericFunction) &@op@_arg@op@_int32_loop,
    (PyUFuncGenericFunction) &@op@_arg@op@_uint32_loop,
    (PyUFuncGenericFunction) &@op@_arg@op@_int64_loop,
    (PyUFuncGenericFunction) &@op@_arg@op@_uint64_loop,
    (PyUFuncGenericFunction) &@op@_arg@op@_float_loop,
    (PyUFuncGenericFunction) &@op@_arg@op@_double_loop,
    (PyUFuncGenericFunction) &@op@_arg@op@_longdouble_loop,
    (PyUFuncGenericFunction) &@op@_arg@op@_object_loop
};

#define @OP@_ARG@OP@_NTYPES (sizeof(@op@_arg@op@_funcs) / sizeof(@op@_arg@op@_funcs[0]))
static void *@op@_arg@op@_data[@OP@_ARG@OP@_NTYPES];

/**end repeat**/

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// Python extension module definitions.
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

static PyMethodDef MinMaxMethods[] = {
        {NULL, NULL, 0, NULL}
};

static struct PyModuleDef moduledef = {
    PyModuleDef_HEAD_INIT,
    .m_name = "_minmax",
    .m_doc = "Module that defines the minmax and argminmax functions.",
    .m_size = -1,
    .m_methods = MinMaxMethods
};

#define ARGMIN_DOCSTRING \
"argmin(x, /, ...)\n"                                           \
"\n"                                                            \
"Compute the index of the minimum of the input.\n"

#define ARGMAX_DOCSTRING \
"argmax(x, /, ...)\n"                                           \
"\n"                                                            \
"Compute the index of the maximum of the input.\n"

#define MINMAX_DOCSTRING \
"minmax(x, /, ...)\n"                                           \
"\n"                                                            \
"Compute minimum and maximum of the input.\n"

#define ARGMINMAX_DOCSTRING \
"argminmax(x, /, ...)\n"                                        \
"\n"                                                            \
"Compute indices of the minimum and maximum of the input.\n"

#define MIN_ARGMIN_DOCSTRING \
"min_argmin(x, /, ...)\n"                                       \
"\n"                                                            \
"Compute the minimum and index of the minimum of the input.\n"

#define MAX_ARGMAX_DOCSTRING \
"max_argmax(x, /, ...)\n"                                       \
"\n"                                                            \
"Compute the maximum and index of the maximum of the input.\n"


PyMODINIT_FUNC PyInit__minmax(void)
{
    PyObject *module;

    module = PyModule_Create(&moduledef);
    if (!module) {
        return NULL;
    }

    import_array();
    import_umath();

    // Create the minmax ufunc.
    if (ul_define_gufunc(module, "minmax", MINMAX_DOCSTRING, "(i)->(2)",
                         MINMAX_NTYPES,
                         minmax_funcs, minmax_data, minmax_typecodes) < 0) {
        Py_DECREF(module);
        return NULL;
    }

    // Create the argminmax ufunc.
    if (ul_define_gufunc(module, "argminmax", ARGMINMAX_DOCSTRING, "(i)->(2)",
                         ARGMINMAX_NTYPES,
                         argminmax_funcs, argminmax_data, argminmax_typecodes) < 0) {
        Py_DECREF(module);
        return NULL;
    }

/**begin repeat
 *
 * #op = min, max#
 * #OP = MIN, MAX#
 */

    // Create the arg@op@ ufunc.
    if (ul_define_gufunc(module, "arg@op@", ARG@OP@_DOCSTRING, "(i)->()",
                         ARG@OP@_NTYPES,
                         arg@op@_funcs, arg@op@_data, arg@op@_typecodes) < 0) {
        Py_DECREF(module);
        return NULL;
    }


    // Create the @op@_arg@op@ ufunc.
    if (ul_define_gufunc(module, "@op@_arg@op@", @OP@_ARG@OP@_DOCSTRING, "(i)->(),()",
                         @OP@_ARG@OP@_NTYPES,
                         @op@_arg@op@_funcs, @op@_arg@op@_data, @op@_arg@op@_typecodes) < 0) {
        Py_DECREF(module);
        return NULL;
    }

/**end repeat**/

    return module;
}
