# Experimental code for generating wrappers of ufuncs that have a
# nicer API.  Specifically, in the wrappers, give the core parameters
# nicer names, and make them keyword parameters.  For example, instead
# of
#     vnorm(x1, x2, ...)
#     backlash(x1, x2, x2, ...)
#
# the signatures of the wrappers of `vnorm` and `backlash` are
#
#     vnorm(x, p, ...)
#     backlash(x, deadband, initial)
#
# In fact, vnorm is wrapped so that a default value of p is provided:
#
#     vnorm(x, p=2, ...)


def get_input_sig_strings(ufunc):
    if ufunc.signature is not None:
        return ufunc.signature.split('->')[0][1:-1].split('),(')
    else:
        return ['']*ufunc.nin


def make_self_assignment(s):
    # `s` must be a string that contains one '='.
    left, right = s.split('=')
    return '='.join([left, left])


def check_params(params, ufunc):
    if ufunc.nout > 1:
        multi_out_params = [f'out{k}' for k in range(1, ufunc.nout + 1)]
    else:
        multi_out_params = []
    # Note:
    #  * `where` is a parameer of plain ufuncs only.
    #  * `axis`, `axes` and `keepdims` are parameters of gufuncs only.
    all_ufunc_params = ['out', 'casting', 'order', 'dtype', 'subok',
                        'signature', 'extobj', 'where',
                        'axis', 'axes', 'keepdims'] + multi_out_params
    args = []
    kwargs = []
    for item in params:
        if isinstance(item, str):
            name = item
            args.append(name)
            if len(kwargs) > 0:
                raise ValueError(f"{ufunc.__name__}: parameter {name} must "
                                 "have a default value")
        else:
            name = item[0]
            kwargs.append(item)
        if name in all_ufunc_params:
            raise ValueError(f"{ufunc.__name__}: parameter '{name}' is also "
                             "a ufunc parameter.")
    return args, kwargs


def to_lines(line, offset):
    parts = line.split(', ')
    lines = []
    pad = 0
    while len(parts) > 0:
        k = 0
        n = 0
        while k != len(parts) and n + pad + len(parts[k]) + 2 < 80:
            n += len(parts[k]) + 2
            k += 1
        if k == len(parts):
            final = ''
        else:
            final = ','
        lines.append(' '*pad + ', '.join(parts[:k]) + final)
        pad = offset
        parts = parts[k:]

    return lines


def get_def_and_call_sig(ufunc, params):
    if ufunc.nout > 1:
        out_arg = f"out={(None,)*ufunc.nout}"
    else:
        out_arg = "out=None"
    common_args = [out_arg, "casting='same_kind'", "order='K'", "dtype=None",
                   "subok=True", "signature=None", "extobj=None"]
    ufunc_only_args = ['where=True']
    gufunc_only_args = ["axis=None", "axes=None", "keepdims=None"]
    if ufunc.signature is None:
        control_args = common_args + ufunc_only_args
    else:
        control_args = common_args + gufunc_only_args
    args, kwargs = check_params(params, ufunc)
    kwdstrs = ([f'{name}={value!r}' for name, value in kwargs]
               + control_args)
    def_sig = ', '.join(args + ['*'] + kwdstrs)
    call_sig = ', '.join(args + [kw[0] for kw in kwargs]
                         + [make_self_assignment(arg) for arg in control_args])
    return def_sig, call_sig


def uwrap(ufunc, namespace, params=None, name=None):
    """
    ufunc : NumPy ufunc or gufunc
        The function to be given a wrapper.
    namespace : str
        The namespace in which ufunc is defined.
    params : list of str
        The parameter names to be used in the signature of
        the wrapper for the core parameters.  I.e. these are
        the names that replace the generic names that are
        generated by NumPy.
    name : str
        The name of the wrapper function.  If not given,
        ``ufunc.__name__`` is used.
    """
    if name is None:
        name = ufunc.__name__

    if params is None:
        # Get the third line of the docstring.  This skips the two lines
        # added to the docstring by the NumPy code, and gets the line that
        # has the form
        #     name(arg1, args2, ...)
        # This is a convention used in ufunclab when creating the docstrings.
        # It is not automatically generated by NumPy, and it is not required
        # by NumPy, so this will not work with ufuncs that do not follow the
        # convention (e.g. np.sin, or any other NumPy ufunc).
        sigline = ufunc.__doc__.splitlines()[2].strip()
        k = sigline.find('(')
        params = sigline[k+1:-6].split(', ')

    nin = ufunc.nin
    if len(params) != nin:
        raise ValueError(f'ufunc has {nin} input arguments, but '
                         f'len(params) is {len(params)}')

    def_sig, call_sig = get_def_and_call_sig(ufunc, params)

    source = []

    # First line is def statement of the wrapper.
    line = f"def {name}({def_sig}):"
    source.extend(to_lines(line, offset=5 + len(name)))

    # Copy the docstring.
    source.append('    """')
    source.extend(['    ' + line for line in ufunc.__doc__.splitlines()])
    source.append('    """')

    ufunc_name = namespace + ('.' if namespace else '') + ufunc.__name__
    call_ufunc = f"    return {ufunc_name}({call_sig})"
    source.extend(to_lines(call_ufunc, offset=12+len(ufunc_name)))
    source.append('')

    return '\n'.join(source)


wrapper_preamble = '''
"""
Wrappers for the functions in ufunclab.

This modules defines wrapper functions for the functions in ufunclab.
The wrapper functions have descriptive parameter names for the core
parameters instead of the geneeric names that are generated by NumPy
(e.g. (`x`, or `x1`, `x2`, ...) .  These parameters are keyword parameters,
so the functions may be called with keyword assignment rather than with
purely positional arguments.


"""

import ufunclab
'''


if __name__ == "__main__":
    from datetime import datetime
    from os.path import basename
    # Run this after ufunclab has been installed.
    import ufunclab as ul

    # Get all the ufuncs (plain ufuncs and gufuncs) in the `ufunclab`
    # namespace.
    funcs = [getattr(ul, name) for name in dir(ul)
             if (not name.startswith('_')
                 and name not in ['op', 'ufunc_inspector'])]

    with open('wrappers.py', 'w') as f:
        f.write(f"# Do not edit this file!\n"
                f"# This file was generated by '{basename(__file__)}'"
                f" on {datetime.now()}.\n")
        f.write(wrapper_preamble)
        for ufunc in funcs:
            f.write("\n\n")
            # Currently the only function for which a parameter with a default
            # is provided is vnorm (p=2):
            if ufunc.__name__ == 'vnorm':
                params = ['x', ('p', 2)]
            else:
                # Get the params from the docstring.
                params=None
            s = uwrap(ufunc, namespace="ufunclab", params=params)
            f.write(s)
