//
// deadzone_ufunc.c.src
//
// ufunc implementation of deadzone(x, low, high)
//

#define PY_SSIZE_T_CLEAN
#include "Python.h"

#include <stddef.h>
#include <stdint.h>

#define NPY_NO_DEPRECATED_API NPY_API_VERSION
#include "numpy/ndarraytypes.h"
#include "numpy/arrayscalars.h"
#include "numpy/ufuncobject.h"


// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// ufunc inner loops for floating point types.
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

/**begin repeat
 * #typename      = float, double, longdouble#
 * #ctype         = float, double, long double#
 */

static void deadzone_@typename@_loop(char **args, const npy_intp *dimensions,
                                     const npy_intp* steps, void* data)
{
    // args[0]: pointer to x array
    // args[1]: pointer to low array
    // args[2]: pointer to high array
    // args[3]: pointer to output array
    // dimensions[0]: Length of each array
    // steps[0]:  x array step
    // steps[1]:  low array step
    // steps[2]:  high array step
    // steps[3]:  output array step
    char *px = args[0];
    char *plow = args[1];
    char *phigh = args[2];
    char *pout = args[3];
    npy_intp n = dimensions[0];

    for (int j = 0; j < n; ++j, px += steps[0], plow += steps[1],
                                phigh += steps[2], pout += steps[3]) {
        @ctype@ x = *((@ctype@ *) px);
        @ctype@ low = *((@ctype@ *) plow);
        @ctype@ high = *((@ctype@ *) phigh);
        if (x < low) {
            *((@ctype@ *) pout) = x - low;
        }
        else if (x > high) {
            *((@ctype@ *) pout) = x - high;
        }
        else {
            *((@ctype@ *) pout) = 0;
        }
    }
}

/**end repeat**/


// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// ufunc configuration data.
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

// These are the input and return dtypes of deadzone.
static char types[] = {
    NPY_FLOAT, NPY_FLOAT, NPY_FLOAT, NPY_FLOAT,
    NPY_DOUBLE, NPY_DOUBLE, NPY_DOUBLE, NPY_DOUBLE,
    NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE
};

static PyUFuncGenericFunction deadzone_funcs[] = {
    (PyUFuncGenericFunction) &deadzone_float_loop,
    (PyUFuncGenericFunction) &deadzone_double_loop,
    (PyUFuncGenericFunction) &deadzone_longdouble_loop
};

static void *deadzone_data[sizeof(deadzone_funcs)/sizeof(deadzone_funcs[0])];


// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// Python extension module definitions.
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

static PyMethodDef DeadzoneMethods[] = {
        {NULL, NULL, 0, NULL}
};

static struct PyModuleDef moduledef = {
    PyModuleDef_HEAD_INIT,
    .m_name = "_deadzone",
    .m_doc = "Module that defines the deadzone function.",
    .m_size = -1,
    .m_methods = DeadzoneMethods
};


#define DEADZONE_DOCSTRING \
"deadzone(x, low, high, /, ...)\n"                          \
"\n"                                                        \
"Compute the deadzone transform of the input signal x.\n"   \
"The function is also known as a soft threshold.\n"         \
"\n"                                                        \
"Parameters\n"                                              \
"----------\n"                                              \
"x : array_like\n"                                          \
"    Input signal\n"                                        \
"low : array_like\n"                                        \
"    Low end of the dead zone.\n"                           \
"high : array_like\n"                                       \
"    High end of the dead zone.\n"                          \
"\n"                                                        \
"Returns\n"                                                 \
"-------\n"                                                 \
"out : ndarray\n"                                           \
"    Output of the deadzone transform.\n"                   \
"\n"                                                        \
"Notes\n"                                                   \
"-----\n"                                                   \
"The function expects ``low <= high``.  It does not check\n"\
"that this condition is satisifed.\n"                       \
"\n"                                                        \
"Examples\n"                                                \
"--------\n"                                                \
">>> x = np.array([-1, -0.75, -0.5, -0.25, 0, 0.25, 0.5])\n"\
">>> deadzone(x, -0.25, 0.1)\n"                             \
"array([-0.75, -0.5 , -0.25,  0.  ,  0.  ,  0.15,  0.4 ])\n"\
"\n"

PyMODINIT_FUNC PyInit__deadzone(void)
{
    PyObject *m;
    PyUFuncObject *deadzone_ufunc;
    size_t ntypes;
    int nin, nout;
    int status;

    m = PyModule_Create(&moduledef);
    if (!m) {
        return NULL;
    }

    import_array();
    import_umath();

    // Create the deadzone ufunc.
    ntypes = sizeof(deadzone_funcs) / sizeof(deadzone_funcs[0]);
    nin = 3;
    nout = 1;
    deadzone_ufunc = (PyUFuncObject *) PyUFunc_FromFuncAndData(
                            deadzone_funcs, deadzone_data, types, ntypes, nin, nout,
                            PyUFunc_None, "deadzone",
                            DEADZONE_DOCSTRING, 0);
    if (deadzone_ufunc == NULL) {
        Py_DECREF(m);
        return NULL;
    }
    status = PyModule_AddObject(m, "deadzone", (PyObject *) deadzone_ufunc);
    if (status == -1) {
        Py_DECREF(deadzone_ufunc);
        Py_DECREF(m);
        return NULL;
    }

    return m;
}
