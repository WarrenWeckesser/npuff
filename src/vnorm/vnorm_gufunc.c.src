//
// vnorm_gufunc.c.src
//
// gufunc implementation of the vector norm.
//

#define PY_SSIZE_T_CLEAN
#include "Python.h"

#include <stddef.h>
#include <stdint.h>
#include <complex.h>
#include <math.h>

#define NPY_NO_DEPRECATED_API NPY_API_VERSION
#include "numpy/ndarraytypes.h"
#include "numpy/arrayscalars.h"
#include "numpy/ufuncobject.h"

#include "../util/ufunc_tools.h"


// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// ufunc inner loops for floating point types.
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

/**begin repeat
 * #typename      = float, double, longdouble#
 * #ctype         = float, double, long double#
 * #c             = f,,l#
 * #C             = F,,L#
 */

static void vnorm_@typename@_loop(char **args, const npy_intp *dimensions,
                                  const npy_intp* steps, void* data)
{
    // dimensions[0]: Number of input arrays
    // dimensions[1]: Length of each array
    // steps[0]:  x array outer step
    // steps[1]:  order array step
    // steps[2]:  output array step
    // steps[3]:  inner (core) x array step
    char *px = args[0];
    char *porder = args[1];
    char *pout = args[2];
    npy_intp nloops = dimensions[0];

    for (int j = 0; j < nloops; ++j, px += steps[0], porder += steps[1],
                                     pout += steps[2]) {
        @ctype@ maxabsx = 0;
        @ctype@ order = *((@ctype@ *) porder);
        if (order <= 0) {
            ((@ctype@ *) pout)[0] = NPY_NAN;
            continue;
        }

        for (int k = 0; k < dimensions[1]; ++k) {
            @ctype@ current_x = ((@ctype@ *) px)[k];
            if (current_x < 0) {
                current_x = -current_x;
            }
            if (current_x > maxabsx) {
                maxabsx = current_x;
            }
        }
        if (maxabsx == 0) {
            ((@ctype@ *) pout)[0] = 0;
        }
        else {
            @ctype@ sum = 0;
            for (int k = 0; k < dimensions[1]; ++k) {
                @ctype@ current_x = *((@ctype@ *) (px + k*steps[3]));
                if (current_x < 0) {
                    current_x = -current_x;
                }
                if (npy_isinf(order)) {
                    sum = fmax@c@(sum, current_x);
                }
                else if (order == 1) {
                    sum += current_x;
                }
                else {
                    sum += pow@c@(current_x/maxabsx, order);
                }
            }
            if (npy_isinf(order) | (order == 1)) {
                ((@ctype@ *) pout)[0] = sum;
            }
            else {
                ((@ctype@ *) pout)[0] = maxabsx * pow@c@(sum, 1/order);
            }
        }
    }
}

/**end repeat**/

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// ufunc inner loops for complex floating point types.
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

/**begin repeat
 * #typename      = cfloat, cdouble, clongdouble#
 * #crealtype     = float, double, long double#
 * #ccplxtype     = complex float, complex double, complex long double#
 * #c             = f,,l#
 * #C             = F,,L#
 */

static void vnorm_@typename@_loop(char **args, const npy_intp *dimensions,
                                  const npy_intp* steps, void* data)
{
    // dimensions[0]: Number of input arrays
    // dimensions[1]: Length of each array
    // steps[0]:  x array outer step
    // steps[1]:  order array step
    // steps[2]:  output array step
    // steps[3]:  inner (core) x array step
    char *px = args[0];
    char *porder = args[1];
    char *pout = args[2];
    npy_intp nloops = dimensions[0];

    for (int j = 0; j < nloops; ++j, px += steps[0], porder += steps[1],
                                     pout += steps[2]) {
        @crealtype@ maxmag = 0;
        @crealtype@ order = *((@crealtype@ *) porder);
        if (order <= 0) {
            ((@crealtype@ *) pout)[0] = NPY_NAN;
            continue;
        }

        for (int k = 0; k < dimensions[1]; ++k) {
            @ccplxtype@ current_x = ((@ccplxtype@ *) px)[k];
            @crealtype@ mag = cabs@c@(current_x);
            if (mag > maxmag) {
                maxmag = mag;
            }
        }
        if (maxmag == 0) {
            ((@ccplxtype@ *) pout)[0] = 0;
        }
        else {
            @crealtype@ sum = 0;
            for (int k = 0; k < dimensions[1]; ++k) {
                @ccplxtype@ current_x = *((@ccplxtype@ *) (px + k*steps[3]));
                @crealtype@ mag = cabs@c@(current_x);
                if (npy_isinf(order)) {
                    sum = fmax@c@(sum, mag);
                }
                else if (order == 1) {
                    sum += mag;
                }
                else {
                    sum += pow@c@(mag/maxmag, order);
                }
            }
            if (npy_isinf(order) | (order == 1)) {
                ((@crealtype@ *) pout)[0] = sum;
            }
            else {
                ((@crealtype@ *) pout)[0] = maxmag * pow@c@(sum, 1/order);
            }
        }
    }
}

/**end repeat**/

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// ufunc configuration data.
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

// These are the input and return dtypes of vnorm.
static char vnorm_typecodes[] = {
    NPY_FLOAT, NPY_FLOAT, NPY_FLOAT,
    NPY_DOUBLE, NPY_DOUBLE, NPY_DOUBLE,
    NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE,
    NPY_CFLOAT, NPY_FLOAT, NPY_FLOAT,
    NPY_CDOUBLE, NPY_DOUBLE, NPY_DOUBLE,
    NPY_CLONGDOUBLE, NPY_LONGDOUBLE, NPY_LONGDOUBLE
};

static PyUFuncGenericFunction vnorm_funcs[] = {
    (PyUFuncGenericFunction) &vnorm_float_loop,
    (PyUFuncGenericFunction) &vnorm_double_loop,
    (PyUFuncGenericFunction) &vnorm_longdouble_loop,
    (PyUFuncGenericFunction) &vnorm_cfloat_loop,
    (PyUFuncGenericFunction) &vnorm_cdouble_loop,
    (PyUFuncGenericFunction) &vnorm_clongdouble_loop
};

#define VNORM_NTYPES  (sizeof(vnorm_funcs)/sizeof(vnorm_funcs[0]))
static void *vnorm_data[VNORM_NTYPES];


// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// Python extension module definitions.
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

static PyMethodDef VNormMethods[] = {
        {NULL, NULL, 0, NULL}
};

static struct PyModuleDef moduledef = {
    PyModuleDef_HEAD_INIT,
    .m_name = "_vnorm",
    .m_doc = "Module that defines the vnorm function.",
    .m_size = -1,
    .m_methods = VNormMethods
};


#define VNORM_DOCSTRING \
"vnorm(x, p, ...)\n"                                        \
"\n"                                                        \
"Compute the vector norm of the input signal x.\n"          \
"\n"                                                        \
"Parameters\n"                                              \
"----------\n"                                              \
"x : array_like\n"                                          \
"    Input array\n"                                         \
"p : scalar or array_like\n"                                \
"    Order of the norm to be computed (e.g. p=2 is the\n"   \
"    standard Euclidean norm). Must be greater than 0.\n"   \
"\n"                                                        \
"Returns\n"                                                 \
"-------\n"                                                 \
"out : ndarray\n"                                           \
"    Vector norm(s) of the input.\n"                        \
"\n"                                                        \
"Examples\n"                                                \
"--------\n"                                                \
">>> x = np.array([30.0, 40.0])\n"                          \
">>> vnorm(x, 2)\n"                                         \
"50.0\n"                                                    \
">>> z = np.array([[-2j, 3+4j, 0, 14], [3, -12j, 3j, 2-2j]])\n" \
">>> vnorm(z, 2, axis=1)\n"                                     \
"array([15.        , 13.03840481])\n"                           \
">>> vnorm(z, 2, axis=0)\n"                                     \
"array([ 3.60555128, 13.        ,  3.        , 14.28285686])\n" \
"\n"


PyMODINIT_FUNC PyInit__vnorm(void)
{
    PyObject *module;

    module = PyModule_Create(&moduledef);
    if (!module) {
        return NULL;
    }

    import_array();
    import_umath();

    // Create the vnorm ufunc.
    if (ul_define_gufunc(module, "vnorm", VNORM_DOCSTRING, "(i),()->()",
                         VNORM_NTYPES,
                         vnorm_funcs, vnorm_data, vnorm_typecodes) < 0) {
        Py_DECREF(module);
        return NULL;
    }

    return module;
}
